<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>BAMBOO FLOW - STABLE ORDER</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-font-smoothing: antialiased; }
        body { background: #1a1a1a; font-family: 'Poppins', sans-serif; overflow: hidden; height: 100vh; width: 100vw; touch-action: none; }

        .bg-glass {
            position: fixed; inset: 0; z-index: -1;
            background: url('image-10.png') center/cover no-repeat;
            transform: scale(1.8); filter: blur(60px) brightness(0.4); opacity: 1;
        }

        #lineCanvas { position: fixed; inset: 0; z-index: 50; pointer-events: none; }

        .center-hub {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            z-index: 1000;
        }
        .main-avatar {
            width: 76px; height: 76px; border-radius: 50%; border: 1.5px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1); overflow: hidden; box-shadow: 0 0 20px rgba(0,0,0,0.2);
            cursor: default; pointer-events: auto;
        }
        .main-avatar img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }

        #hidden-trigger { position: fixed; bottom: 0; left: 0; width: 100%; height: 12%; z-index: 2000; }

        #stage { position: absolute; inset: 0; z-index: 100; pointer-events: none; }
        .bubble {
            position: absolute; left: 0; top: 0; border-radius: 50%; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.12); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2); cursor: grab; pointer-events: auto;
            opacity: 0; will-change: transform, opacity; transition: opacity 1s ease-out;
            display: flex; align-items: center; justify-content: center;
        }
        .bubble.spawned { opacity: 1; }
        
        .photo-placeholder { width: 32px; height: 32px; fill: rgba(255,255,255,0.4); }
        
        .bubble.is-text { 
            padding: 18px; font-size: 11px; color: rgba(255,255,255,0.8); 
            text-align: center; line-height: 1.4; overflow: hidden;
        }

        .unread-dot {
            position: absolute; top: 18px; right: 18px; 
            width: 8px; height: 8px; background: #ff3b30; border-radius: 50%; z-index: 200;
        }

        #modal-overlay {
            position: fixed; inset: 0; z-index: 6000; display: none; align-items: center; justify-content: center;
            backdrop-filter: blur(40px); background: rgba(0,0,0,0.3); opacity: 0; transition: 0.4s;
        }
        #modal-overlay.active { display: flex; opacity: 1; }
        .modal-card { background: white; padding: 30px; border-radius: 30px; width: 80%; max-width: 300px; }
    </style>
</head>
<body>

    <div class="bg-glass"></div>
    <canvas id="lineCanvas"></canvas>
    <div id="hidden-trigger" onclick="spawnBubble()"></div>

    <div id="modal-overlay" onclick="closeModal()">
        <div class="modal-card" onclick="event.stopPropagation()"><p id="m-text"></p></div>
    </div>

    <div class="center-hub">
        <div class="main-avatar">
            <img src="image-10.png">
        </div>
    </div>
    <div id="stage"></div>

    <script>
        const stage = document.getElementById('stage');
        const canvas = document.getElementById('lineCanvas');
        const ctx = canvas.getContext('2d');
        let bubbles = [];
        let count = 0;
        let draggedBubble = null;

        const photoIcon = `<svg class="photo-placeholder" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>`;

        const dataPool = [
            { type: 'text', content: "Flowing together in harmony." },
            { type: 'img', content: 'image-10.png' },
            { type: 'text', content: "Sequence creates the melody of flow." },
            { type: 'img', content: 'image-10.png' }
        ];

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.onresize = resize; resize();

        function spawnBubble() {
            const data = dataPool[count % dataPool.length];
            const el = document.createElement('div');
            el.className = `bubble is-${data.type}`;
            el.innerHTML = `<div class="unread-dot"></div>${data.type === 'img' ? photoIcon : data.content}`;
            stage.appendChild(el);

            const ww = window.innerWidth, wh = window.innerHeight;
            const cx = ww/2 - 60, cy = wh/2 - 60;
            const angle = Math.random() * Math.PI * 2;
            const bObj = { el, r: 60, x: cx + Math.cos(angle)*200, y: cy + Math.sin(angle)*200, vx: 0, vy: 0, isDragged: false, data: data };

            let downTime;
            el.onmousedown = el.ontouchstart = (e) => { draggedBubble = bObj; bObj.isDragged = true; downTime = Date.now(); };
            el.onmouseup = el.ontouchend = () => { if(Date.now() - downTime < 200) openModal(bObj); };

            bubbles.push(bObj);
            el.style.transform = `translate3d(${bObj.x}px, ${bObj.y}px, 0)`;
            requestAnimationFrame(() => el.classList.add('spawned'));
            count++;
        }

        window.onmousemove = (e) => { if (draggedBubble) { draggedBubble.x = e.clientX - 60; draggedBubble.y = e.clientY - 60; } };
        window.ontouchmove = (e) => { if (draggedBubble) { draggedBubble.x = e.touches[0].clientX - 60; draggedBubble.y = e.touches[0].clientY - 60; } };
        window.onmouseup = window.ontouchend = () => { if(draggedBubble) draggedBubble.isDragged = false; draggedBubble = null; };

        function openModal(b) {
            document.getElementById('m-text').innerText = b.data.content;
            document.getElementById('modal-overlay').style.display = 'flex';
            setTimeout(() => document.getElementById('modal-overlay').classList.add('active'), 10);
        }
        function closeModal() {
            document.getElementById('modal-overlay').classList.remove('active');
            setTimeout(() => document.getElementById('modal-overlay').style.display = 'none', 400);
        }

        function animate(time) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const ww = window.innerWidth, wh = window.innerHeight, cx = ww / 2, cy = wh / 2;

            // 1. 连线与绳子力
            if (bubbles.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                bubbles.forEach((b, i) => {
                    let prevX = cx, prevY = cy;
                    if (i > 0) { prevX = bubbles[i-1].x + 60; prevY = bubbles[i-1].y + 60; }
                    const currX = b.x + 60, currY = b.y + 60;
                    const dx = currX - prevX, dy = currY - prevY;
                    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                    const restLen = 300; 

                    if (dist > restLen) {
                        const pull = (dist - restLen) * 0.02;
                        if (!b.isDragged) { b.vx -= (dx / dist) * pull; b.vy -= (dy / dist) * pull; }
                        if (i > 0 && !bubbles[i-1].isDragged) { bubbles[i-1].vx += (dx / dist) * pull; bubbles[i-1].vy += (dy / dist) * pull; }
                    }
                    const midX = (prevX + currX) / 2, midY = (prevY + currY) / 2;
                    ctx.moveTo(prevX, prevY);
                    ctx.quadraticCurveTo(midX, midY + Math.sin(time*0.002+i)*5, currX, currY);
                });
                ctx.stroke();
            }

            // 2. 物理核心
            bubbles.forEach((b, i) => {
                if (!b.isDragged) {
                    const dx = (b.x + 60) - cx, dy = (b.y + 60) - cy, dist = Math.sqrt(dx*dx + dy*dy) || 1;

                    // 自由漂浮力
                    b.vx += (-dy/dist) * 0.0008; 
                    b.vx += (cx - (b.x+60)) * 0.00003;

                    // 碰撞检测（避开重叠）
                    bubbles.forEach((b2, j) => {
                        if(i === j) return;
                        const pdx = (b2.x+60) - (b.x+60), pdy = (b2.y+60) - (b.y+60), pdist = Math.sqrt(pdx*pdx + pdy*pdy) || 1;
                        if(pdist < 130) {
                            const p = (130 - pdist) * 0.02;
                            b.vx -= (pdx/pdist)*p; b.vy -= (pdy/pdist)*p;
                        }
                    });

                    // 避开中心
                    if(dist < 100) {
                        const p = (100 - dist) * 0.05;
                        b.vx += (dx/dist)*p; b.vy += (dy/dist)*p;
                    }

                    b.vx *= 0.92; b.vy *= 0.92;
                    b.x += b.vx; b.y += b.vy;
                }
                // 强制边界限制
                b.x = Math.max(0, Math.min(ww - 120, b.x));
                b.y = Math.max(0, Math.min(wh - 120, b.y));
                b.el.style.transform = `translate3d(${b.x}px, ${b.y}px, 0)`;
            });
            requestAnimationFrame(animate);
        }
        animate(0);
    </script>
</body>
</html>
